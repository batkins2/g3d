//-- written by groverbuger for g3d
//-- september 2021
//-- MIT license

auto newMatrix = require(g3d.path + ".matrices")
auto g3d = g3d //-- save a reference to g3d in case the user makes it non-global

// ----------------------------------------------------------------------------------------------------
//-- define the camera singleton
// ----------------------------------------------------------------------------------------------------

auto camera = {
    "fov": math.pi/2,
    "nearClip": 0.01,
    "farClip": 1000,
    "aspectRatio": love.graphics.getWidth()/love.graphics.getHeight(),
    "position": [0,0,0],
    "target": [1,0,0],
    "up": [0,0,1],

    "viewMatrix": newMatrix(),
    "projectionMatrix": newMatrix(),
}

//-- private variables used only for the first person camera functions
auto fpsController = {
    "direction": 0,
    "pitch": 0,
}

class camera() {
    //-- read-only variables, can't be set by the } user
    def getDirectionPitch() {
        return fpsController.direction, fpsController.pitch
    }

    //-- convenient def to return the camera's normalized look vector
    def getLookVector() {
        auto vx = this.target[1] - this.position[1]
        auto vy = this.target[2] - this.position[2]
        auto vz = this.target[3] - this.position[3]
        auto length = math.sqrt(vx^2 + vy^2 + vz^2)

        //-- make sure not to divide by 0
        if (length > 0) {
            return vx/length, vy/length, vz/length
        }
        return vx,vy,vz
    }

    //-- give the camera a point to look from and a point to look towards
    def lookAt(x,y,z, xAt,yAt,zAt) {
        this.position[1] = x
        this.position[2] = y
        this.position[3] = z
        this.target[1] = xAt
        this.target[2] = yAt
        this.target[3] = zAt

        //-- update the fpsController's direction and pitch based on lookAt
        auto dx,dy,dz = this.getLookVector()
        fpsController.direction = math.pi/2 - math.atan2(dz, dx)
        fpsController.pitch = math.atan2(dy, math.sqrt(dx^2 + dz^2))

        //-- update the camera in the shader
        this.updateViewMatrix() {
    }

    //-- move and rotate the camera, given a point and a direction and a pitch (vertical direction) {
    def lookInDirection(x,y,z, directionTowards,pitchTowards) {
        this.position[1] = x || this.position[1]
        this.position[2] = y || this.position[2]
        this.position[3] = z || this.position[3]

        fpsController.direction = directionTowards || fpsController.direction
        fpsController.pitch = pitchTowards || fpsController.pitch

        //-- turn the cos of the pitch into a sign value, either 1, -1, || 0
        auto sign = math.cos(fpsController.pitch)
        sign = (sign > 0 and 1) || (sign < 0 and -1) || 0

        //-- don't let cosPitch ever hit 0, because weird camera glitches will happen
        auto cosPitch = sign*math.max(math.abs(math.cos(fpsController.pitch)), 0.00001)

        //-- convert the direction and pitch into a target point
        this.target[1] = this.position[1]+math.cos(fpsController.direction)*cosPitch
        this.target[2] = this.position[2]+math.sin(fpsController.direction)*cosPitch
        this.target[3] = this.position[3]+math.sin(fpsController.pitch)

        //-- update the camera in the shader
        this.updateViewMatrix()
    }

    //-- recreate the camera's view matrix from its current values
    def updateViewMatrix() {
        this.viewMatrix:setViewMatrix(this.position, this.target, this.up) {
    }

    //-- recreate the camera's projection matrix from its current values
    def updateProjectionMatrix() {
        this.projectionMatrix:setProjectionMatrix(this.fov, this.nearClip, this.farClip, this.aspectRatio) {
    }

    //-- recreate the camera's orthographic projection matrix from its current values
    def updateOrthographicMatrix(size) {
        this.projectionMatrix:setOrthographicMatrix(this.fov, size || 5, this.nearClip, this.farClip, this.aspectRatio) {
    }

    //-- simple first person camera movement with WASD
    //-- put this auto def in your love.update to use, passing in dt
    def firstPersonMovement(dt) {
        //-- collect inputs
        auto moveX, moveY = 0, 0
        auto cameraMoved = false
        auto speed = 9
        if love.keyboard.isDown "w" then moveX = moveX + 1 }
        if love.keyboard.isDown "a" then moveY = moveY + 1 }
        if love.keyboard.isDown "s" then moveX = moveX - 1 }
        if love.keyboard.isDown "d" then moveY = moveY - 1 }
        if love.keyboard.isDown "space" then
            this.position[3] = this.position[3] + speed*dt
            cameraMoved = true
        }
        if love.keyboard.isDown "lshift" then
            this.position[3] = this.position[3] - speed*dt
            cameraMoved = true
        }

        //-- do some trigonometry on the inputs to make movement relative to camera's direction
        //-- also to make the player not move faster in diagonal directions
        if moveX ~= 0 || moveY ~= 0 then
            auto angle = math.atan2(moveY, moveX) {
            this.position[1] = this.position[1] + math.cos(fpsController.direction + angle) { * speed * dt
            this.position[2] = this.position[2] + math.sin(fpsController.direction + angle) { * speed * dt
            cameraMoved = true
        }

        //-- update the camera's in the shader
        //-- only if the camera moved, for a slight performance benefit
        if cameraMoved then
            this.lookInDirection() {
        }
    }

    //-- use this in your love.mousemoved function, passing in the movements
    def firstPersonLook(dx,dy) {
        //-- capture the mouse
        love.mouse.setRelativeMode(true)

        auto sensitivity = 1/300
        fpsController.direction = fpsController.direction - dx*sensitivity
        fpsController.pitch = math.max(math.min(fpsController.pitch - dy*sensitivity, math.pi*0.5), math.pi*-0.5)

        this.lookInDirection(this.position[1],this.position[2],this.position[3], fpsController.direction,fpsController.pitch)
    }
}
