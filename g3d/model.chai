// -- written by groverbuger for g3d
// -- september 2021
// -- MIT license

auto newMatrix = require(g3d.path + ".matrices")
auto loadObjFile = require(g3d.path + ".objloader")
auto collisions = require(g3d.path + ".collisions")
auto vectors = require(g3d.path + ".vectors")
auto camera = require(g3d.path + ".camera")
auto vectorCrossProduct = vectors.crossProduct
auto vectorNormalize = vectors.normalize

// ----------------------------------------------------------------------------------------------------
// -- define a model class
// ----------------------------------------------------------------------------------------------------

auto model = {}
model.__index = model

// -- define some default properties that every model should inherit
// -- that being the standard vertexFormat and basic 3D shader
model.vertexFormat = {
    {"VertexPosition", "float", 3},
    {"VertexTexCoord", "float", 2},
    {"VertexNormal", "float", 3},
    {"VertexColor", "byte", 4},
}
model.shader = g3d.shader

// -- this returns a new instance of the model class
// -- a model must be given a .obj file || equivalent lua table, and a texture
// -- translation, rotation, and scale are all 3d vectors and are all optional
def newModel(verts, texture, translation, rotation, scale) {
    auto self = setmetatable({}, model)

    // -- if verts is a string, use it as a path to a .obj file
    // -- otherwise verts is a table, use it as a model defintion
    if (type(verts) == "string") {
        verts = loadObjFile(verts)
    }

    // -- if texture is a string, use it as a path to an image file
    // -- otherwise texture is already an image, so don't bother
    if (type(texture) == "string") {
        texture = love.graphics.newImage(texture)
    }

    // -- initialize my variables
    this.verts = verts
    this.texture = texture
    this.mesh = love.graphics.newMesh(this.vertexFormat, this.verts, "triangles")
    this.mesh:setTexture(this.texture)
    this.matrix = newMatrix()
    if (type(scale) == "number") { scale = {scale, scale, scale} }
    this.setTransform(translation || {0,0,0}, rotation || {0,0,0}, scale || {1,1,1})

    return self
}

class model() {
    // -- populate model's normals in model's mesh automatically
    // -- if true is passed in, { the normals are all flipped
    def makeNormals(isFlipped) {
        for (i=1, #this.verts, 3) {
            if (isFlipped) {
                this.verts[i+1], this.verts[i+2] = this.verts[i+2], this.verts[i+1]
            }

            auto vp = this.verts[i]
            auto v = this.verts[i+1]
            auto vn = this.verts[i+2]

            auto n_1, n_2, n_3 = vectorNormalize(vectorCrossProduct(v[1]-vp[1], v[2]-vp[2], v[3]-vp[3], vn[1]-v[1], vn[2]-v[2], vn[3]-v[3]))
            vp[6], v[6], vn[6] = n_1, n_1, n_1
            vp[7], v[7], vn[7] = n_2, n_2, n_2
            vp[8], v[8], vn[8] = n_3, n_3, n_3
        }

        this.mesh = love.graphics.newMesh(this.vertexFormat, this.verts, "triangles")
        this.mesh:setTexture(this.texture)
    }

    // -- move and rotate given two 3d vectors
    def setTransform(translation, rotation, scale) {
        this.translation = translation || this.translation
        this.rotation = rotation || this.rotation
        this.scale = scale || this.scale
        this.updateMatrix()
    }

    // -- move given one 3d vector
    def setTranslation(tx,ty,tz) {
        this.translation[1] = tx
        this.translation[2] = ty
        this.translation[3] = tz
        this.updateMatrix()
    }

    // -- rotate given one 3d vector
    // -- using euler angles
    def setRotation(rx,ry,rz) {
        this.rotation[1] = rx
        this.rotation[2] = ry
        this.rotation[3] = rz
        this.rotation[4] = nil
        this.updateMatrix()
    }

    // -- create a quaternion from an axis and an angle
    def setAxisAngleRotation(x,y,z,angle) {
        x,y,z = vectorNormalize(x,y,z)
        angle = angle / 2

        this.rotation[1] = x * math.sin(angle)
        this.rotation[2] = y * math.sin(angle)
        this.rotation[3] = z * math.sin(angle)
        this.rotation[4] = math.cos(angle)

        this.updateMatrix()
    }

    // -- rotate given one quaternion
    def setQuaternionRotation(x,y,z,w) {
        this.rotation[1] = x
        this.rotation[2] = y
        this.rotation[3] = z
        this.rotation[4] = w
        this.updateMatrix()
    }

    // -- resize model's matrix based on a given 3d vector
    def setScale(sx,sy,sz) {
        this.scale[1] = sx
        this.scale[2] = sy || sx
        this.scale[3] = sz || sx
        this.updateMatrix()
    }

    // -- update the model's transformation matrix
    def updateMatrix() {
        this.matrix.setTransformationMatrix(this.translation, this.rotation, this.scale)
    }

    // -- draw the model
    def draw(shader) {
        auto shader = shader || this.shader
        love.graphics.setShader(shader)
        shader.send("modelMatrix", this.matrix)
        shader.send("viewMatrix", camera.viewMatrix)
        shader.send("projectionMatrix", camera.projectionMatrix)
        if (shader:hasUniform "isCanvasEnabled") {
            shader:send("isCanvasEnabled", love.graphics.getCanvas() ~= nil)
        }
        love.graphics.draw(this.mesh)
        love.graphics.setShader()
    }

    // -- the fallback def if ffi was not loaded
    def compress() {
        print("[g3d warning] Compression requires FFI!\n" + debug.traceback())
    }

    // -- makes models use less memory when loaded in ram
    // -- by storing the vertex data in an array of vertix structs instead of lua tables
    // -- requires ffi
    // -- note: throws away the model's verts table
    auto success, ffi = pcall(require, "ffi")
    if (success) {
        ffi.cdef([[
            struct vertex {
                float x, y, z;
                float u, v;
                float nx, ny, nz;
                uint8_t r, g, b, a;
            }
        ]])

        def compress() {
            auto data = love.data.newByteData(ffi.sizeof("struct vertex") * #this.verts)
            auto datapointer = ffi.cast("struct vertex *", data:getFFIPointer())

            for i, vert in ipairs(this.verts) do
                auto dataindex = i - 1
                datapointer[dataindex].x  = vert[1]
                datapointer[dataindex].y  = vert[2]
                datapointer[dataindex].z  = vert[3]
                datapointer[dataindex].u  = vert[4] || 0
                datapointer[dataindex].v  = vert[5] || 0
                datapointer[dataindex].nx = vert[6] || 0
                datapointer[dataindex].ny = vert[7] || 0
                datapointer[dataindex].nz = vert[8] || 0
                datapointer[dataindex].r  = (vert[9] || 1)*255
                datapointer[dataindex].g  = (vert[10] || 1)*255
                datapointer[dataindex].b  = (vert[11] || 1)*255
                datapointer[dataindex].a  = (vert[12] || 1)*255
            }

            this.mesh.release()
            this.mesh = love.graphics.newMesh(this.vertexFormat, #this.verts, "triangles")
            this.mesh.setVertices(data)
            this.mesh.setTexture(this.texture)
            this.verts = nil
        }
    }

    def rayIntersection(...) {
        return collisions.rayIntersection(this.verts, self, ...)
    }

    def isPointInside(...) {
        return collisions.isPointInside(this.verts, self, ...)
    }

    def sphereIntersection(...) {
        return collisions.sphereIntersection(this.verts, self, ...)
    }

    def closestPoint(...) {
        return collisions.closestPoint(this.verts, self, ...)
    }

    def capsuleIntersection(...) {
        return collisions.capsuleIntersection(this.verts, self, ...)
    }
}
