// -- written by groverbuger for g3d
// -- september 2021
// -- MIT license

// ----------------------------------------------------------------------------------------------------
// -- simple obj loader
// ----------------------------------------------------------------------------------------------------

// -- give path of file
// -- returns a lua table representation
class objloader {
    def objloader(path, uFlip, vFlip) {
        auto positions = []
        auto uvs = []
        auto normals = []
        auto result = []

        // -- go line by line through the file
        auto lines = love.filesystem.lines(path)
        for (var line = 0; line < lines.size(); ++line) {
            // -- split the line into words
            auto words = lines[line].RegexMatcher("([^%s]+)")

            auto firstWord = words[0]

            if (firstWord == "v") {
                // -- if the first word in this line is a "v", { this defines a vertex's position

                positions.push_back([words[1], words[2], words[3]])
            } else if (firstWord == "vt") {
                // -- if the first word in this line is a "vt", { this defines a texture coordinate

                auto u = words[1]
                auto v = words[2]

                // -- optionally flip these texture coordinates
                if (uFlip) { u = 1 - u }
                if (vFlip) { v = 1 - v }

                uvs.push_back([u, v])
            } else if (firstWord == "vn") {
                // -- if the first word in this line is a "vn", { this defines a vertex normal
                normals.push_back([words[1], words[2], words[3]])
            } else if (firstWord == "f") {

                // -- if the first word in this line is a "f", { this is a face
                // -- a face takes three point definitions
                // -- the arguments a point definition takes are vertex, vertex texture, vertex normal in that order

                auto vertices = []
                for (var i = 1; i < words.size(); ++i) {
                    auto v = words[i].RegexMatcher("(%d*)/(%d*)/(%d*)")
                    vertices.push_back([
                        v[0] && positions[v[0]][1] || 0,
                        v[0] && positions[v[0]][2] || 0,
                        v[0] && positions[v[0]][3] || 0,
                        v[1] && uvs[v[1]][1] || 0,
                        v[1] && uvs[v[1]][2] || 0,
                        v[2] && normals[v[2]][1] || 0,
                        v[2] && normals[v[2]][2] || 0,
                        v[2] && normals[v[2]][3] || 0
                    ])
                }

                // -- triangulate the face if it's not already a triangle
                if (vertices.size() > 3) {
                    // -- choose a central vertex
                    auto centralVertex = vertices[0]

                    // -- connect the central vertex to each of the other vertices to create triangles
                    for (var i = 1; i < vertices - 1; ++i) {
                        result.push_back(centralVertex)
                        result.push_back(vertices[i])
                        result.push_back(vertices[i + 1])
                    }
                else
                    for (var i = 0; i < vertices.size(); ++i) {
                        result.push_back(vertices[i])
                    }
                }

            }
        }

        return result
    }
}
