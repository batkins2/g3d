// written by groverbuger for g3d with split-screen support
// september 2021
// MIT license

uniform sampler2D shadowMap;

uniform sampler2D specularMap;

flat varying int shadowOut;

flat varying int isSpecularOut;

// Split-screen configuration (controlled by CPU)
varying float splitScreenModeOut; // 0=off, 1=2x2 grid, 2=2x1 vertical, 3=1x2 horizontal
flat varying int currentViewID; // Which view/player is currently being rendered (0-3)

varying vec3 lighting;
varying vec4 fragPosLightSpace;
varying vec2 vTexCoord;

float grid(vec2 vBC, float width) {
    vec3 bary = vec3(vBC.x, vBC.y, 1.0 - vBC.x - vBC.y);
    vec3 d = fwidth(bary);
    vec3 a3 = smoothstep(d * (width - 0.5), d * (width + 0.5), bary);
    return min(min(a3.x, a3.y), a3.z);
}

float ShadowCalculation() {
    vec3 projCoords = fragPosLightSpace.xyz / fragPosLightSpace.w;
    projCoords = projCoords * 0.5 + 0.5;
    
    // Early out if outside shadow map bounds
    if (projCoords.x < 0.0 || projCoords.x > 1.0 || 
        projCoords.y < 0.0 || projCoords.y > 1.0 || 
        projCoords.z > 1.0) {
        return 0.0;
    }
    
    float closestDepth = texture2D(shadowMap, projCoords.xy).r;
    float currentDepth = projCoords.z;
    return currentDepth > closestDepth ? 0.5 : 0.0;
}

vec4 effect(vec4 color, Image texture, vec2 texture_coords, vec2 screen_coords) { 
    float splitX = 0.5; // Vertical split at 50%
    float splitY = 0.5; // Horizontal split at 50%
    
    // Scissor-based split-screen: discard pixels outside current view's viewport
    if (splitScreenModeOut == 1.0) {
        // 2x2 grid - each view gets a quadrant
        if (currentViewID == 0) {
            // Bottom-left quadrant
            if (screen_coords.x >= splitX || screen_coords.y >= splitY) {
                discard;
            }
        } else if (currentViewID == 1) {
            // Bottom-right quadrant
            if (screen_coords.x < splitX || screen_coords.y >= splitY) {
                discard;
            }
        } else if (currentViewID == 2) {
            // Top-left quadrant
            if (screen_coords.x >= splitX || screen_coords.y < splitY) {
                discard;
            }
        } else if (currentViewID == 3) {
            // Top-right quadrant
            if (screen_coords.x < splitX || screen_coords.y < splitY) {
                discard;
            }
        }
    } else if (splitScreenModeOut == 2.0) {
        // 2x1 vertical split
        if (currentViewID == 0) {
            // Left half
            if (screen_coords.x >= splitX) {
                discard;
            }
        } else {
            // Right half
            if (screen_coords.x < splitX) {
                discard;
            }
        }
    } else if (splitScreenModeOut == 3.0) {
        // 1x2 horizontal split
        if (currentViewID == 1) {
            // Bottom half
            if (screen_coords.y < splitY) {
                discard;
            }
        // } else {
        //     // Top half
        //     if (screen_coords.y < splitY) {
        //         discard;
        //     }
        }
    }
    
    // Draw split-screen borders (thin lines at split boundaries)
    float borderWidth = 0.002;
    if (splitScreenModeOut > 0.0) {
        if ((abs(screen_coords.x - splitX) < borderWidth && splitScreenModeOut != 3.0) ||
            (abs(screen_coords.y - splitY) < borderWidth && splitScreenModeOut != 2.0)) {
            return vec4(0.1, 0.1, 0.1, 1.0); // Dark border
        }
    }
    
    vec4 pixel = Texel(texture, texture_coords);
    
    // Calculate shadows once for both paths
    float shadows = 0.0;
    if (shadowOut == 1) {
        shadows = ShadowCalculation();
    }

    if (isSpecularOut == 1) {
        vec3 specularColor = texture2D(specularMap, vec2(vTexCoord.x, 1.0 - vTexCoord.y)).rgb;

        // Hardcoded vectors - could be uniforms for better performance
        vec3 viewDir = vec3(0.0, 0.0, 1.0);
        vec3 normal = vec3(0.0, 0.0, 1.0);
        vec3 lightDir = vec3(0.0, 0.0, 1.0);
        vec3 reflectDir = reflect(-lightDir, normal);
        float spec = pow(max(dot(viewDir, reflectDir), 0.0), 16.0);

        vec3 specular = specularColor * spec;
        vec3 baseColor = (1.0 - shadows) * (pixel.rgb * lighting * 0.5);
        vec3 blendedColor = mix(baseColor, baseColor + specular * 0.75, 0.5);
    
        return vec4(blendedColor, pixel.a) * color.a;
    } else {
        vec3 baseColor = (1.0 - shadows) * (pixel.rgb * lighting);
        return vec4(baseColor, pixel.a) * color.a;
    }    
}